{"posts":[{"title":"Zhenlin Wang (Criss)","text":"Welcome to my personal website! I'm Zhenlin Wang. You can call me Criss if it's easier for you. I'm currently studying for a Master of Machine Learning degree in Carnegie Mellon University. Before coming to the US, I completed my undergraduate study at National University of Singapore (NUS). My academic and practical interests lie in the intersection of data science, machine learning and software engineering, and I've been actively seeking for SDE/MLE internships recently. If you are interested to know more about me as a person, you can find some information [here]. What's in my websiteThis is a space to drop down some notes about my life. I started maintaining this website from my sophomore year in NUS. The original version used a minimal-mistake style and I've migrated into the hexo-icarus style on Aug 2022. There are several sections in this space: 1. Technical BlogsBlogs about various topics in DS/AI/ML and software engineering are written here. The mathematical/technical details are presented. I often included some discussion about the pros/cons of the methodologies outlined in these blogs. Nonetheless, I never believe that any blog post can be &quot;DONE&quot; as new perspectives on these topics can always supplement what's on the posts. Thus, I consistently update these posts whenever I learn some new knowledge about the topics discussed in these posts. Disclaimer: I try my best to give credit for all sources I made referenecs to. If you found some parts in my post that were referenced from your work without credit, please kindly contact me so I can immediately correct my mistakes and make apology. 2. Experience and skill setMy project experiences are listed here for record, many are driven by the interests to explore tech/skills I never knew. I'm eager to understand the basics of various technology toolkits and learn new stuff along the way. 3. Anime and EnlightenmentThese posts will be more of a casual type. I watch anime once in a while, especially those classical series that touched me deeply in heart. I've decided to reflect upon reviewing these series and drop them down here. Sometimes I meditate ((aka. emo)) or read. Now that I think it's a good idea to take note of them so that I won't waste time repeating myself during my meditations. Special thanksIn retrospect, I did make various references to many websites/blogs when building this version of personal space. I've got to thank @Lei Mao for the inspiration to build a website from scratch. I followed him since 2018 when I read his background story and found it so motivating. Learning from his blog styles, I built my first version of website and the journey of bloghing started afterwards. When trying to customizing the pages, I learnt so much from @iMaeGoo, @Xinyu Liu and @Pengyuan Li. I should thank them for their great tutorials on website styling.","link":"/post/Zhenlin%20Wang/"},{"title":"Gradient Descent Algorithm and Its Variants!","text":"Overview of Gradient DescentOptimization refers to the task of minimizing/maximizing an objective function parameterized by . In machine/deep learning terminology, it’s the task of minimizing the cost/loss function parameterized by the model’s parameters . Optimization algorithms (in case of minimization) have one of the following goals: Find the global minimum of the objective function. This is feasible if the objective function is convex, i.e. any local minimum is a global minimum. Find the lowest possible value of the objective function within its neighbor. That’s usually the case if the objective function is not convex as the case in most deep learning problems. There are three kinds of optimization algorithms: Optimization algorithm that is not iterative and simply solves for one point. Optimization algorithm that is iterative in nature and converges to acceptable solution regardless of the parameters initialization such as gradient descent applied to logistic regression. Optimization algorithm that is iterative in nature and applied to a set of problems that have non-convex cost functions such as neural networks. Therefore, parameters’ initialization plays a critical role in speeding up convergence and achieving lower error rates. Gradient Descent is the most common optimization algorithm in machine learning and deep learning. It is a first-order optimization algorithm. This means it only takes into account the first derivative when performing the updates on the parameters. On each iteration, we update the parameters in the opposite direction of the gradient of the objective function w.r.t to the parameters where the gradient gives the direction of the steepest ascent. The size of the step we take on each iteration to reach the local minimum is determined by the learning rate . Therefore, we follow the direction of the slope downhill until we reach a local minimum. In this notebook, we’ll cover gradient descent algorithm and its variants: Batch Gradient Descent, Mini-batch Gradient Descent, and Stochastic Gradient Descent. Let’s first see how gradient descent and its associated steps works on logistic regression before going into the details of its variants. For the sake of simplicity, let’s assume that the logistic regression model has only two parameters: weight and bias . Initialize weight and bias to any random numbers. Pick a value for the learning rate . The learning rate determines how big the step would be on each iteration. If is very small, it would take long time to converge and become computationally expensive. IF is large, it may fail to converge and overshoot the minimum. Therefore, plot the cost function against different values of and pick the value of that is right before the first value that didn’t converge so that we would have a very fast learning algorithm that converges (Figure 1). Figure 2 The most commonly used rates are : 0.001, 0.003, 0.01, 0.03, 0.1, 0.3. Make sure to scale the data if it’s on very different scales. If we don’t scale the data, the level curves (contours) would be narrower and taller which means it would take longer time to converge (Figure 2). Figure 2 Scale the data to have and . Below is the formula for scaling each example: On each iteration, take the partial derivative of the cost function w.r.t each parameter (gradient): The update equations are: For the sake of illustration, assume we don’t have bias. If the slope of the current values of , this means that we are to the right of optimal . Therefore, the update will be negative, and will start getting close to the optimal values of . However, if it’s negative, the update will be positive and will increase the current values of to converge to the optimal values of (Figure 3): Figure 3 Continue the process until the cost function converges. That is, until the error curve becomes flat and doesn’t change. In addition, on each iteration, the step would be in the direction that gives the maximum change since it’s perpendicular to level curves at each step. Now let’s discuss the three variants of gradient descent algorithm. The main difference between them is the amount of data we use when computing the gradients for each learning step. The trade-off between them is the accuracy of the gradient versus the time complexity to perform each parameter’s update (learning step). Batch Gradient DescentBatch Gradient Descent is when we sum up over all examples on each iteration when performing the updates to the parameters. Therefore, for each update, we have to sum over all examples: manual gradient update123for i in range(num_epochs): grad = compute_gradient(data, params) params = params - learning_rate * grad The main advantages: We can use fixed learning rate during training without worrying about learning rate decay. It has straight trajectory towards the minimum and it is guaranteed to converge in theory to the global minimum if the loss function is convex and to a local minimum if the loss function is not convex. It has unbiased estimate of gradients. The more the examples, the lower the standard error. The main disadvantages: Even though we can use vectorized implementation, it may still be slow to go over all examples especially when we have large datasets. Each step of learning happens after going over all examples where some examples may be redundant and don’t contribute much to the update. Mini-Batch Gradient DescentInstead of going over all examples, Mini-batch Gradient Descent sums up over lower number of examples based on batch size. Therefore, learning happens on each mini-batch of examples: Shuffle the training dataset to avoid pre-existing order of examples. Partition the training dataset into mini-batches based on the batch size. If the training set size is not divisible by batch size, the remaining will be its own batch. manual gradient update minibatch12345for i in range(num_epochs): np.random.shuffle(data) for batch in radom_minibatches(data, batch_size=32): grad = compute_gradient(batch, params) params = params - learning_rate * grad The batch size is something we can tune. It is usually chosen as power of 2 such as 32, 64, 128, 256, 512, etc. The reason behind it is because some hardware such as GPUs achieve better runtime with common batch sizes such as power of 2. The main advantages: Faster than Batch version because it goes through a lot less examples than Batch (all examples). Randomly selecting examples will help avoid redundant examples or examples that are very similar that don’t contribute much to the learning. With batch size &lt; size of training set, it adds noise to the learning process that helps improving generalization error. Even though with more examples the estimate would have lower standard error, the return is less than linear compared to the computational burden we incur. The main disadvantages: It won’t converge. On each iteration, the learning step may go back and forth due to the noise. Therefore, it wanders around the minimum region but never converges. Due to the noise, the learning steps have more oscillations (see figure 5) and requires adding learning-decay to decrease the learning rate as we become closer to the minimum. Figure 4 With large training datasets, we don’t usually need more than 2-10 passes over all training examples (epochs). Note: with batch size , we get the Batch Gradient Descent. Stochastic Gradient DescentInstead of going through all examples, Stochastic Gradient Descent (SGD) performs the parameters update on each example . Therefore, learning happens on every example: Shuffle the training dataset to avoid pre-existing order of examples. Partition the training dataset into examples. manual gradient update stochastic12345for i in range(num_epochs): np.random.shuffle(data) for example in data: grad = compute_gradient(example, params) params = params - learning_rate * grad It shares most of the advantages and the disadvantages with mini-batch version. Below are the ones that are specific to SGD: It adds even more noise to the learning process than mini-batch that helps improving generalization error. However, this would increase the run time. We can’t utilize vectorization over 1 example and becomes very slow. Also, the variance becomes large since we only use 1 example for each learning step. Below is a graph that shows the gradient descent’s variants and their direction towards the minimum: Figure 5 As the figure above shows, SGD direction is very noisy compared to mini-batch. Areas for advancementBelow are some challenges regarding gradient descent algorithm in general as well as its variants - mainly batch and mini-batch: Gradient descent is a first-order optimization algorithm, which means it doesn’t take into account the second derivatives of the cost function. However, the curvature of the function affects the size of each learning step. The gradient measures the steepness of the curve but the second derivative measures the curvature of the curve. Therefore, if: Second derivative = 0 the curvature is linear. Therefore, the step size = the learning rate . Second derivative &gt; 0 the curvature is going upward. Therefore, the step size &lt; the learning rate and may lead to divergence. Second derivative &lt; 0 the curvature is going downward. Therefore, the step size &gt; the learning rate . As a result, the direction that looks promising to the gradient may not be so and may lead to slow the learning process or even diverge. If Hessian matrix has poor conditioning number, i.e. the direction of the most curvature has much more curvature than the direction of the lowest curvature. This will lead the cost function to be very sensitive in some directions and insensitive in other directions. As a result, it will make it harder on the gradient because the direction that looks promising for the gradient may not lead to big changes in the cost function. The norm of the gradient is supposed to decrease slowly with each learning step because the curve is getting flatter and steepness of the curve will decrease. However, we see that the norm of the gradient is increasing, because of the curvature of the curve. Nonetheless, even though the gradients’ norm is increasing, we’re able to achieve a very low error rates (see figure 8). In small dimensions, local minimum is common; however, in large dimensions, saddle points are more common. Saddle point is when the function curves up in some directions and curves down in other directions. In other words, saddle point looks a minimum from one direction and a maximum from other direction (see figure 9). This happens when at least one eigenvalue of the hessian matrix is negative and the rest of eigenvalues are positive. As discussed previously, choosing a proper learning rate is hard. Also, for mini-batch gradient descent, we have to adjust the learning rate during the training process to make sure it converges to the local minimum and not wander around it. Figuring out the decay rate of the learning rate is also hard and changes with different datasets. All parameter updates have the same learning rate; however, we may want to perform larger updates to some parameters that have their directional derivatives more inline with the trajectory towards the minimum than other parameters.","link":"/post/gradient-descent%20copy%202/"},{"title":"Gradient Descent Algorithm and Its Variants!","text":"Overview of Gradient DescentOptimization refers to the task of minimizing/maximizing an objective function parameterized by . In machine/deep learning terminology, it’s the task of minimizing the cost/loss function parameterized by the model’s parameters . Optimization algorithms (in case of minimization) have one of the following goals: Find the global minimum of the objective function. This is feasible if the objective function is convex, i.e. any local minimum is a global minimum. Find the lowest possible value of the objective function within its neighbor. That’s usually the case if the objective function is not convex as the case in most deep learning problems. There are three kinds of optimization algorithms: Optimization algorithm that is not iterative and simply solves for one point. Optimization algorithm that is iterative in nature and converges to acceptable solution regardless of the parameters initialization such as gradient descent applied to logistic regression. Optimization algorithm that is iterative in nature and applied to a set of problems that have non-convex cost functions such as neural networks. Therefore, parameters’ initialization plays a critical role in speeding up convergence and achieving lower error rates. Gradient Descent is the most common optimization algorithm in machine learning and deep learning. It is a first-order optimization algorithm. This means it only takes into account the first derivative when performing the updates on the parameters. On each iteration, we update the parameters in the opposite direction of the gradient of the objective function w.r.t to the parameters where the gradient gives the direction of the steepest ascent. The size of the step we take on each iteration to reach the local minimum is determined by the learning rate . Therefore, we follow the direction of the slope downhill until we reach a local minimum. In this notebook, we’ll cover gradient descent algorithm and its variants: Batch Gradient Descent, Mini-batch Gradient Descent, and Stochastic Gradient Descent. Let’s first see how gradient descent and its associated steps works on logistic regression before going into the details of its variants. For the sake of simplicity, let’s assume that the logistic regression model has only two parameters: weight and bias . Initialize weight and bias to any random numbers. Pick a value for the learning rate . The learning rate determines how big the step would be on each iteration. If is very small, it would take long time to converge and become computationally expensive. IF is large, it may fail to converge and overshoot the minimum. Therefore, plot the cost function against different values of and pick the value of that is right before the first value that didn’t converge so that we would have a very fast learning algorithm that converges (Figure 1). Figure 2 The most commonly used rates are : 0.001, 0.003, 0.01, 0.03, 0.1, 0.3. Make sure to scale the data if it’s on very different scales. If we don’t scale the data, the level curves (contours) would be narrower and taller which means it would take longer time to converge (Figure 2). Figure 2 Scale the data to have and . Below is the formula for scaling each example: On each iteration, take the partial derivative of the cost function w.r.t each parameter (gradient): The update equations are: For the sake of illustration, assume we don’t have bias. If the slope of the current values of , this means that we are to the right of optimal . Therefore, the update will be negative, and will start getting close to the optimal values of . However, if it’s negative, the update will be positive and will increase the current values of to converge to the optimal values of (Figure 3): Figure 3 Continue the process until the cost function converges. That is, until the error curve becomes flat and doesn’t change. In addition, on each iteration, the step would be in the direction that gives the maximum change since it’s perpendicular to level curves at each step. Now let’s discuss the three variants of gradient descent algorithm. The main difference between them is the amount of data we use when computing the gradients for each learning step. The trade-off between them is the accuracy of the gradient versus the time complexity to perform each parameter’s update (learning step). Batch Gradient DescentBatch Gradient Descent is when we sum up over all examples on each iteration when performing the updates to the parameters. Therefore, for each update, we have to sum over all examples: manual gradient update123for i in range(num_epochs): grad = compute_gradient(data, params) params = params - learning_rate * grad The main advantages: We can use fixed learning rate during training without worrying about learning rate decay. It has straight trajectory towards the minimum and it is guaranteed to converge in theory to the global minimum if the loss function is convex and to a local minimum if the loss function is not convex. It has unbiased estimate of gradients. The more the examples, the lower the standard error. The main disadvantages: Even though we can use vectorized implementation, it may still be slow to go over all examples especially when we have large datasets. Each step of learning happens after going over all examples where some examples may be redundant and don’t contribute much to the update. Mini-Batch Gradient DescentInstead of going over all examples, Mini-batch Gradient Descent sums up over lower number of examples based on batch size. Therefore, learning happens on each mini-batch of examples: Shuffle the training dataset to avoid pre-existing order of examples. Partition the training dataset into mini-batches based on the batch size. If the training set size is not divisible by batch size, the remaining will be its own batch. manual gradient update minibatch12345for i in range(num_epochs): np.random.shuffle(data) for batch in radom_minibatches(data, batch_size=32): grad = compute_gradient(batch, params) params = params - learning_rate * grad The batch size is something we can tune. It is usually chosen as power of 2 such as 32, 64, 128, 256, 512, etc. The reason behind it is because some hardware such as GPUs achieve better runtime with common batch sizes such as power of 2. The main advantages: Faster than Batch version because it goes through a lot less examples than Batch (all examples). Randomly selecting examples will help avoid redundant examples or examples that are very similar that don’t contribute much to the learning. With batch size &lt; size of training set, it adds noise to the learning process that helps improving generalization error. Even though with more examples the estimate would have lower standard error, the return is less than linear compared to the computational burden we incur. The main disadvantages: It won’t converge. On each iteration, the learning step may go back and forth due to the noise. Therefore, it wanders around the minimum region but never converges. Due to the noise, the learning steps have more oscillations (see figure 5) and requires adding learning-decay to decrease the learning rate as we become closer to the minimum. Figure 4 With large training datasets, we don’t usually need more than 2-10 passes over all training examples (epochs). Note: with batch size , we get the Batch Gradient Descent. Stochastic Gradient DescentInstead of going through all examples, Stochastic Gradient Descent (SGD) performs the parameters update on each example . Therefore, learning happens on every example: Shuffle the training dataset to avoid pre-existing order of examples. Partition the training dataset into examples. manual gradient update stochastic12345for i in range(num_epochs): np.random.shuffle(data) for example in data: grad = compute_gradient(example, params) params = params - learning_rate * grad It shares most of the advantages and the disadvantages with mini-batch version. Below are the ones that are specific to SGD: It adds even more noise to the learning process than mini-batch that helps improving generalization error. However, this would increase the run time. We can’t utilize vectorization over 1 example and becomes very slow. Also, the variance becomes large since we only use 1 example for each learning step. Below is a graph that shows the gradient descent’s variants and their direction towards the minimum: Figure 5 As the figure above shows, SGD direction is very noisy compared to mini-batch. Areas for advancementBelow are some challenges regarding gradient descent algorithm in general as well as its variants - mainly batch and mini-batch: Gradient descent is a first-order optimization algorithm, which means it doesn’t take into account the second derivatives of the cost function. However, the curvature of the function affects the size of each learning step. The gradient measures the steepness of the curve but the second derivative measures the curvature of the curve. Therefore, if: Second derivative = 0 the curvature is linear. Therefore, the step size = the learning rate . Second derivative &gt; 0 the curvature is going upward. Therefore, the step size &lt; the learning rate and may lead to divergence. Second derivative &lt; 0 the curvature is going downward. Therefore, the step size &gt; the learning rate . As a result, the direction that looks promising to the gradient may not be so and may lead to slow the learning process or even diverge. If Hessian matrix has poor conditioning number, i.e. the direction of the most curvature has much more curvature than the direction of the lowest curvature. This will lead the cost function to be very sensitive in some directions and insensitive in other directions. As a result, it will make it harder on the gradient because the direction that looks promising for the gradient may not lead to big changes in the cost function. The norm of the gradient is supposed to decrease slowly with each learning step because the curve is getting flatter and steepness of the curve will decrease. However, we see that the norm of the gradient is increasing, because of the curvature of the curve. Nonetheless, even though the gradients’ norm is increasing, we’re able to achieve a very low error rates (see figure 8). In small dimensions, local minimum is common; however, in large dimensions, saddle points are more common. Saddle point is when the function curves up in some directions and curves down in other directions. In other words, saddle point looks a minimum from one direction and a maximum from other direction (see figure 9). This happens when at least one eigenvalue of the hessian matrix is negative and the rest of eigenvalues are positive. As discussed previously, choosing a proper learning rate is hard. Also, for mini-batch gradient descent, we have to adjust the learning rate during the training process to make sure it converges to the local minimum and not wander around it. Figuring out the decay rate of the learning rate is also hard and changes with different datasets. All parameter updates have the same learning rate; however, we may want to perform larger updates to some parameters that have their directional derivatives more inline with the trajectory towards the minimum than other parameters.","link":"/post/gradient-descent%20copy%203/"},{"title":"Gradient Descent Algorithm and Its Variants!","text":"Overview of Gradient DescentOptimization refers to the task of minimizing/maximizing an objective function parameterized by . In machine/deep learning terminology, it’s the task of minimizing the cost/loss function parameterized by the model’s parameters . Optimization algorithms (in case of minimization) have one of the following goals: Find the global minimum of the objective function. This is feasible if the objective function is convex, i.e. any local minimum is a global minimum. Find the lowest possible value of the objective function within its neighbor. That’s usually the case if the objective function is not convex as the case in most deep learning problems. There are three kinds of optimization algorithms: Optimization algorithm that is not iterative and simply solves for one point. Optimization algorithm that is iterative in nature and converges to acceptable solution regardless of the parameters initialization such as gradient descent applied to logistic regression. Optimization algorithm that is iterative in nature and applied to a set of problems that have non-convex cost functions such as neural networks. Therefore, parameters’ initialization plays a critical role in speeding up convergence and achieving lower error rates. Gradient Descent is the most common optimization algorithm in machine learning and deep learning. It is a first-order optimization algorithm. This means it only takes into account the first derivative when performing the updates on the parameters. On each iteration, we update the parameters in the opposite direction of the gradient of the objective function w.r.t to the parameters where the gradient gives the direction of the steepest ascent. The size of the step we take on each iteration to reach the local minimum is determined by the learning rate . Therefore, we follow the direction of the slope downhill until we reach a local minimum. In this notebook, we’ll cover gradient descent algorithm and its variants: Batch Gradient Descent, Mini-batch Gradient Descent, and Stochastic Gradient Descent. Let’s first see how gradient descent and its associated steps works on logistic regression before going into the details of its variants. For the sake of simplicity, let’s assume that the logistic regression model has only two parameters: weight and bias . Initialize weight and bias to any random numbers. Pick a value for the learning rate . The learning rate determines how big the step would be on each iteration. If is very small, it would take long time to converge and become computationally expensive. IF is large, it may fail to converge and overshoot the minimum. Therefore, plot the cost function against different values of and pick the value of that is right before the first value that didn’t converge so that we would have a very fast learning algorithm that converges (Figure 1). Figure 2 The most commonly used rates are : 0.001, 0.003, 0.01, 0.03, 0.1, 0.3. Make sure to scale the data if it’s on very different scales. If we don’t scale the data, the level curves (contours) would be narrower and taller which means it would take longer time to converge (Figure 2). Figure 2 Scale the data to have and . Below is the formula for scaling each example: On each iteration, take the partial derivative of the cost function w.r.t each parameter (gradient): The update equations are: For the sake of illustration, assume we don’t have bias. If the slope of the current values of , this means that we are to the right of optimal . Therefore, the update will be negative, and will start getting close to the optimal values of . However, if it’s negative, the update will be positive and will increase the current values of to converge to the optimal values of (Figure 3): Figure 3 Continue the process until the cost function converges. That is, until the error curve becomes flat and doesn’t change. In addition, on each iteration, the step would be in the direction that gives the maximum change since it’s perpendicular to level curves at each step. Now let’s discuss the three variants of gradient descent algorithm. The main difference between them is the amount of data we use when computing the gradients for each learning step. The trade-off between them is the accuracy of the gradient versus the time complexity to perform each parameter’s update (learning step). Batch Gradient DescentBatch Gradient Descent is when we sum up over all examples on each iteration when performing the updates to the parameters. Therefore, for each update, we have to sum over all examples: manual gradient update123for i in range(num_epochs): grad = compute_gradient(data, params) params = params - learning_rate * grad The main advantages: We can use fixed learning rate during training without worrying about learning rate decay. It has straight trajectory towards the minimum and it is guaranteed to converge in theory to the global minimum if the loss function is convex and to a local minimum if the loss function is not convex. It has unbiased estimate of gradients. The more the examples, the lower the standard error. The main disadvantages: Even though we can use vectorized implementation, it may still be slow to go over all examples especially when we have large datasets. Each step of learning happens after going over all examples where some examples may be redundant and don’t contribute much to the update. Mini-Batch Gradient DescentInstead of going over all examples, Mini-batch Gradient Descent sums up over lower number of examples based on batch size. Therefore, learning happens on each mini-batch of examples: Shuffle the training dataset to avoid pre-existing order of examples. Partition the training dataset into mini-batches based on the batch size. If the training set size is not divisible by batch size, the remaining will be its own batch. manual gradient update minibatch12345for i in range(num_epochs): np.random.shuffle(data) for batch in radom_minibatches(data, batch_size=32): grad = compute_gradient(batch, params) params = params - learning_rate * grad The batch size is something we can tune. It is usually chosen as power of 2 such as 32, 64, 128, 256, 512, etc. The reason behind it is because some hardware such as GPUs achieve better runtime with common batch sizes such as power of 2. The main advantages: Faster than Batch version because it goes through a lot less examples than Batch (all examples). Randomly selecting examples will help avoid redundant examples or examples that are very similar that don’t contribute much to the learning. With batch size &lt; size of training set, it adds noise to the learning process that helps improving generalization error. Even though with more examples the estimate would have lower standard error, the return is less than linear compared to the computational burden we incur. The main disadvantages: It won’t converge. On each iteration, the learning step may go back and forth due to the noise. Therefore, it wanders around the minimum region but never converges. Due to the noise, the learning steps have more oscillations (see figure 5) and requires adding learning-decay to decrease the learning rate as we become closer to the minimum. Figure 4 With large training datasets, we don’t usually need more than 2-10 passes over all training examples (epochs). Note: with batch size , we get the Batch Gradient Descent. Stochastic Gradient DescentInstead of going through all examples, Stochastic Gradient Descent (SGD) performs the parameters update on each example . Therefore, learning happens on every example: Shuffle the training dataset to avoid pre-existing order of examples. Partition the training dataset into examples. manual gradient update stochastic12345for i in range(num_epochs): np.random.shuffle(data) for example in data: grad = compute_gradient(example, params) params = params - learning_rate * grad It shares most of the advantages and the disadvantages with mini-batch version. Below are the ones that are specific to SGD: It adds even more noise to the learning process than mini-batch that helps improving generalization error. However, this would increase the run time. We can’t utilize vectorization over 1 example and becomes very slow. Also, the variance becomes large since we only use 1 example for each learning step. Below is a graph that shows the gradient descent’s variants and their direction towards the minimum: Figure 5 As the figure above shows, SGD direction is very noisy compared to mini-batch. Areas for advancementBelow are some challenges regarding gradient descent algorithm in general as well as its variants - mainly batch and mini-batch: Gradient descent is a first-order optimization algorithm, which means it doesn’t take into account the second derivatives of the cost function. However, the curvature of the function affects the size of each learning step. The gradient measures the steepness of the curve but the second derivative measures the curvature of the curve. Therefore, if: Second derivative = 0 the curvature is linear. Therefore, the step size = the learning rate . Second derivative &gt; 0 the curvature is going upward. Therefore, the step size &lt; the learning rate and may lead to divergence. Second derivative &lt; 0 the curvature is going downward. Therefore, the step size &gt; the learning rate . As a result, the direction that looks promising to the gradient may not be so and may lead to slow the learning process or even diverge. If Hessian matrix has poor conditioning number, i.e. the direction of the most curvature has much more curvature than the direction of the lowest curvature. This will lead the cost function to be very sensitive in some directions and insensitive in other directions. As a result, it will make it harder on the gradient because the direction that looks promising for the gradient may not lead to big changes in the cost function. The norm of the gradient is supposed to decrease slowly with each learning step because the curve is getting flatter and steepness of the curve will decrease. However, we see that the norm of the gradient is increasing, because of the curvature of the curve. Nonetheless, even though the gradients’ norm is increasing, we’re able to achieve a very low error rates (see figure 8). In small dimensions, local minimum is common; however, in large dimensions, saddle points are more common. Saddle point is when the function curves up in some directions and curves down in other directions. In other words, saddle point looks a minimum from one direction and a maximum from other direction (see figure 9). This happens when at least one eigenvalue of the hessian matrix is negative and the rest of eigenvalues are positive. As discussed previously, choosing a proper learning rate is hard. Also, for mini-batch gradient descent, we have to adjust the learning rate during the training process to make sure it converges to the local minimum and not wander around it. Figuring out the decay rate of the learning rate is also hard and changes with different datasets. All parameter updates have the same learning rate; however, we may want to perform larger updates to some parameters that have their directional derivatives more inline with the trajectory towards the minimum than other parameters.","link":"/post/gradient-descent%20copy/"},{"title":"Gradient Descent Algorithm and Its Variants!","text":"Overview of Gradient DescentOptimization refers to the task of minimizing/maximizing an objective function parameterized by . In machine/deep learning terminology, it’s the task of minimizing the cost/loss function parameterized by the model’s parameters . Optimization algorithms (in case of minimization) have one of the following goals: Find the global minimum of the objective function. This is feasible if the objective function is convex, i.e. any local minimum is a global minimum. Find the lowest possible value of the objective function within its neighbor. That’s usually the case if the objective function is not convex as the case in most deep learning problems. There are three kinds of optimization algorithms: Optimization algorithm that is not iterative and simply solves for one point. Optimization algorithm that is iterative in nature and converges to acceptable solution regardless of the parameters initialization such as gradient descent applied to logistic regression. Optimization algorithm that is iterative in nature and applied to a set of problems that have non-convex cost functions such as neural networks. Therefore, parameters’ initialization plays a critical role in speeding up convergence and achieving lower error rates. Gradient Descent is the most common optimization algorithm in machine learning and deep learning. It is a first-order optimization algorithm. This means it only takes into account the first derivative when performing the updates on the parameters. On each iteration, we update the parameters in the opposite direction of the gradient of the objective function w.r.t to the parameters where the gradient gives the direction of the steepest ascent. The size of the step we take on each iteration to reach the local minimum is determined by the learning rate . Therefore, we follow the direction of the slope downhill until we reach a local minimum. In this notebook, we’ll cover gradient descent algorithm and its variants: Batch Gradient Descent, Mini-batch Gradient Descent, and Stochastic Gradient Descent. Let’s first see how gradient descent and its associated steps works on logistic regression before going into the details of its variants. For the sake of simplicity, let’s assume that the logistic regression model has only two parameters: weight and bias . Initialize weight and bias to any random numbers. Pick a value for the learning rate . The learning rate determines how big the step would be on each iteration. If is very small, it would take long time to converge and become computationally expensive. IF is large, it may fail to converge and overshoot the minimum. Therefore, plot the cost function against different values of and pick the value of that is right before the first value that didn’t converge so that we would have a very fast learning algorithm that converges (Figure 1). Figure 2 The most commonly used rates are : 0.001, 0.003, 0.01, 0.03, 0.1, 0.3. Make sure to scale the data if it’s on very different scales. If we don’t scale the data, the level curves (contours) would be narrower and taller which means it would take longer time to converge (Figure 2). Figure 2 Scale the data to have and . Below is the formula for scaling each example: On each iteration, take the partial derivative of the cost function w.r.t each parameter (gradient): The update equations are: For the sake of illustration, assume we don’t have bias. If the slope of the current values of , this means that we are to the right of optimal . Therefore, the update will be negative, and will start getting close to the optimal values of . However, if it’s negative, the update will be positive and will increase the current values of to converge to the optimal values of (Figure 3): Figure 3 Continue the process until the cost function converges. That is, until the error curve becomes flat and doesn’t change. In addition, on each iteration, the step would be in the direction that gives the maximum change since it’s perpendicular to level curves at each step. Now let’s discuss the three variants of gradient descent algorithm. The main difference between them is the amount of data we use when computing the gradients for each learning step. The trade-off between them is the accuracy of the gradient versus the time complexity to perform each parameter’s update (learning step). Batch Gradient DescentBatch Gradient Descent is when we sum up over all examples on each iteration when performing the updates to the parameters. Therefore, for each update, we have to sum over all examples: manual gradient update123for i in range(num_epochs): grad = compute_gradient(data, params) params = params - learning_rate * grad The main advantages: We can use fixed learning rate during training without worrying about learning rate decay. It has straight trajectory towards the minimum and it is guaranteed to converge in theory to the global minimum if the loss function is convex and to a local minimum if the loss function is not convex. It has unbiased estimate of gradients. The more the examples, the lower the standard error. The main disadvantages: Even though we can use vectorized implementation, it may still be slow to go over all examples especially when we have large datasets. Each step of learning happens after going over all examples where some examples may be redundant and don’t contribute much to the update. Mini-Batch Gradient DescentInstead of going over all examples, Mini-batch Gradient Descent sums up over lower number of examples based on batch size. Therefore, learning happens on each mini-batch of examples: Shuffle the training dataset to avoid pre-existing order of examples. Partition the training dataset into mini-batches based on the batch size. If the training set size is not divisible by batch size, the remaining will be its own batch. manual gradient update minibatch12345for i in range(num_epochs): np.random.shuffle(data) for batch in radom_minibatches(data, batch_size=32): grad = compute_gradient(batch, params) params = params - learning_rate * grad The batch size is something we can tune. It is usually chosen as power of 2 such as 32, 64, 128, 256, 512, etc. The reason behind it is because some hardware such as GPUs achieve better runtime with common batch sizes such as power of 2. The main advantages: Faster than Batch version because it goes through a lot less examples than Batch (all examples). Randomly selecting examples will help avoid redundant examples or examples that are very similar that don’t contribute much to the learning. With batch size &lt; size of training set, it adds noise to the learning process that helps improving generalization error. Even though with more examples the estimate would have lower standard error, the return is less than linear compared to the computational burden we incur. The main disadvantages: It won’t converge. On each iteration, the learning step may go back and forth due to the noise. Therefore, it wanders around the minimum region but never converges. Due to the noise, the learning steps have more oscillations (see figure 5) and requires adding learning-decay to decrease the learning rate as we become closer to the minimum. Figure 4 With large training datasets, we don’t usually need more than 2-10 passes over all training examples (epochs). Note: with batch size , we get the Batch Gradient Descent. Stochastic Gradient DescentInstead of going through all examples, Stochastic Gradient Descent (SGD) performs the parameters update on each example . Therefore, learning happens on every example: Shuffle the training dataset to avoid pre-existing order of examples. Partition the training dataset into examples. manual gradient update stochastic12345for i in range(num_epochs): np.random.shuffle(data) for example in data: grad = compute_gradient(example, params) params = params - learning_rate * grad It shares most of the advantages and the disadvantages with mini-batch version. Below are the ones that are specific to SGD: It adds even more noise to the learning process than mini-batch that helps improving generalization error. However, this would increase the run time. We can’t utilize vectorization over 1 example and becomes very slow. Also, the variance becomes large since we only use 1 example for each learning step. Below is a graph that shows the gradient descent’s variants and their direction towards the minimum: Figure 5 As the figure above shows, SGD direction is very noisy compared to mini-batch. Areas for advancementBelow are some challenges regarding gradient descent algorithm in general as well as its variants - mainly batch and mini-batch: Gradient descent is a first-order optimization algorithm, which means it doesn’t take into account the second derivatives of the cost function. However, the curvature of the function affects the size of each learning step. The gradient measures the steepness of the curve but the second derivative measures the curvature of the curve. Therefore, if: Second derivative = 0 the curvature is linear. Therefore, the step size = the learning rate . Second derivative &gt; 0 the curvature is going upward. Therefore, the step size &lt; the learning rate and may lead to divergence. Second derivative &lt; 0 the curvature is going downward. Therefore, the step size &gt; the learning rate . As a result, the direction that looks promising to the gradient may not be so and may lead to slow the learning process or even diverge. If Hessian matrix has poor conditioning number, i.e. the direction of the most curvature has much more curvature than the direction of the lowest curvature. This will lead the cost function to be very sensitive in some directions and insensitive in other directions. As a result, it will make it harder on the gradient because the direction that looks promising for the gradient may not lead to big changes in the cost function. The norm of the gradient is supposed to decrease slowly with each learning step because the curve is getting flatter and steepness of the curve will decrease. However, we see that the norm of the gradient is increasing, because of the curvature of the curve. Nonetheless, even though the gradients’ norm is increasing, we’re able to achieve a very low error rates (see figure 8). In small dimensions, local minimum is common; however, in large dimensions, saddle points are more common. Saddle point is when the function curves up in some directions and curves down in other directions. In other words, saddle point looks a minimum from one direction and a maximum from other direction (see figure 9). This happens when at least one eigenvalue of the hessian matrix is negative and the rest of eigenvalues are positive. As discussed previously, choosing a proper learning rate is hard. Also, for mini-batch gradient descent, we have to adjust the learning rate during the training process to make sure it converges to the local minimum and not wander around it. Figuring out the decay rate of the learning rate is also hard and changes with different datasets. All parameter updates have the same learning rate; however, we may want to perform larger updates to some parameters that have their directional derivatives more inline with the trajectory towards the minimum than other parameters.","link":"/post/gradient-descent/"},{"title":"manual","text":"","link":"/post/manual/"}],"tags":[{"name":"Gradient Descent","slug":"Gradient-Descent","link":"/tags/Gradient-Descent/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"front-end","slug":"front-end","link":"/tags/front-end/"},{"name":"blog-building","slug":"blog-building","link":"/tags/blog-building/"}],"categories":[{"name":"Anime","slug":"Anime","link":"/categories/Anime/"},{"name":"Enlightenment","slug":"Enlightenment","link":"/categories/Enlightenment/"},{"name":"Projects","slug":"Projects","link":"/categories/Projects/"},{"name":"Blogs","slug":"Blogs","link":"/categories/Blogs/"}],"pages":[{"title":"404","text":"I don’t know how you ended up here, but you have jumped over the edge of this blog. Maybe it’s the end of the internet and you can power off your machine now… /@@ @@@@@@@@@ @@@@@@@@@ @@@@@@@@@ @@@@@ @@@@@@@@@ ,@@@@@ @@@@@@@@@@ @@@@@@@@@ @@@@@@@@@@ ,@@@@@@@@@@@@ @@@@@@@@@ @@@@@@@@@@@@ @@@@@@@@@@@@ @@@@@@@@@ (@@@@@@@@@@@@ #@@@@@@@@@@@ @@@@@@@@@ @@@@@@@@@@@ @@@@@@@@@@@ @@@@@@@@@ @@@@@@@@@@, @@@@@@@@@. @@@@@@@@@ @@@@@@@@@@ @@@@@@@@@@ @@@@@@@@@ @@@@@@@@@@ @@@@@@@@@ @@@@@@@@ @@@@@@@@@ @@@@@@@@@ @@@@@@@@@ @@@@@@@@@ @@@@@@@@@ @@@@@@@@@@ @@@@@@@@@@ @@@@@@@@@@ @@@@@@@@@@ @@@@@@@@@@ @@@@@@@@@@ @@@@@@@@@@@ @@@@@@@@@@@ @@@@@@@@@@@@@ @@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@ … or you climb back and read one of my recent posts :)","link":"/404.html"},{"title":"About Me","text":"Who am IMy name is Zhenlin Wang. I'm from Ningbo, China. Currently I'm a master student in the Machine Learning Department in Carnegie Mellon University. My academic interest and work passion lie across the fields of Data Science, Machine Learning/AI and Software Engineering (though they are somewhat connected under the field of Computer Science…). The path to my passion Before university, I was quite obsessed with applying mathematical models to the financial industry. I dreamed of being an equity researcher and predicting flows in the stock and derivatives market. In pursuit of this goal, I read an entire textbook on corporate finance and written all kinds of note on accounting models. However, I was wrong. When I entered the equity research team in the investment club in my university, I quickly realized that people were not \"relying\" on the models for judgement. They \"abuse\" these models to fit their assumptions in order to sell their investment plans to customers. This is not what I wanted. So I tried an alternative path - quantitative research. Being an applied math student, it\\'s fairly easy to imagine that I would be fascinated by the significant amount of math used in quantitative research team in the investment club. This stood up as a completely different track from equity research. I was learning so much data science and machine learning knowledge in this team. I knew I\\'ve found my true passion. In the following semester, I enrolled in a second major in Computer Science to learn more about fundamental CS knowledge. I started building up my statistics/data science skills. A youtube channel, StatQuest with Josh Starmer really helped me a lot. Until today, I\\'m glad to see it being supported by the community and is still diligently uploding new tutorials on various concepts in stats/DS/ML. Further down the path, I started exploring boundaries in some ML sub-fields, namly Bayesian Optimization, Bandit and Reinforcement Learning. I conducted several researches under the guidance of my supervisors, and luckily published some papers. I believe in the motto of Learn to live, Live to learn. No matter how old I am and where I am, I\\'ll keep myself challenged with learning new things. At current stage, expanding my passion from theoretical knowledge to real-life application is my major goal. Solving real-world problems with ML breakthroughs require the careful construction of tools and technologies. Thus, learning and practice software engineering has also become part of my life nowadays. Looking backI received my high school and undergradute education in Singapore. It is a second hometown to me. I have no words but only genuine gratitude and respect for this city state. In Singapore, I've met lots of excellent people, learnt countless lessons, and found my true love . My colorful youth life remains in Singapore forever (芳华永驻此狮城~). Leisure timeI listen and play musics sometimes. I used to play violin, but nowadays, I prefer harmonica as I can carry it anywhere easily. I go workout regularly. Since Pittsburgh has lots of tennis court, I'm planning on playing tennis with my friends as well. I love eating Thai food and Japanese food, my favorites are Pat Thai, Basil Chicken, Sushi/sashimi and Suki Yaki. An ACG FanI'm a Japanese culture lover, specifically it's ACG culture and it's history. I read manga, watch anime and used to play some galgame. I used to be quite into the anime merchandise (an otaku) but now I just treat it as an interest and watch some old animes for chilling, I'll casually write some reviews on animes I watched again recently. My favorite anime is Steins;Gate. It tells a story of a man leaping through time challenging destiny using a time machine. My favicon is also a tribute to this series. The perseverence of the main protagonist, Okabe Rintarou, motivated me to keep on despite various setbacks from time to time. Steins Gate - Okabe Rintarou This is the end this self-introduction (you call this an intro???), have fun browsing through my blogs. El Psy Congroo!","link":"/intro/index.html"},{"title":"Publication","text":"Best Arm Identification with Safety Constraints. Zhenlin Wang, Andrew Wagenmaker, Kevin Jamieson.The 25th International Conference on Artificial Intelligence and Statistics (AISTATS), 2022.[arXiv] Max-min Grouped Bandits. Zhenlin Wang, Jonathan Scarlett.Association for the Advancement of Artificial Intelligence (AAAI), 2022.[arXiv]","link":"/publication/index.html"}]}